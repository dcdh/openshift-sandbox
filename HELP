prio:
- des que je me connecte en ssh la vm se "plante" !!! et la resolution ne fonctionne plus :S
  cachesize atteint ...
  tail -f /var/log/messages
  si je vire la dclaration du dns depuis mon HOST tout redeviens normale ... mais je ne peux plus faire de dns vers mes ip ...
Putain je suis con ! j'ai crée une boucle avec le bridge ip qui fait appelle à mon dns et cela en boucle !!


- loop pour tester les dns ...
- sysctl -w net.ipv4.ip_forward=1
- je devris tester le wildcard dns ... test.cluser.....


nmcli dev show eth0 | grep IP4


https://api.ocp4-cluster-001.sandbox.okd:6443/


depuis le bootstrap ssh damien@10.0.5.58
curl -k -v https://localhost:22623/config/master


OK donc tester avec 3 controle plane et 2 workers ...
c'est certainement liée au non respect ...

worker KO !!!!!!!!!!!!!!!!!!!!!!!!!!

/var/log/pods/default_bootstrap-machine-config-operator-bootstrap.ocp4-cluster-001.sandbox.okd_786b1ef2b1954aa7196c3660a8186ff8/machine-config-server
refusing to serve bootstrap configuration to pool "worker"
2020-04-05T21:39:56.812099836+00:00 stderr F E0405 21:39:56.812063       1 api.go:103] couldn't get config for req: {worker}, error: refusing to serve bootstrap configuration to pool "worker"
https://github.com/openshift/machine-config-operator/blob/master/pkg/server/api.go

/etc/mcs/bootstrap/machine-configs
/etc/mcs/bootstrap/machine-pools

/// => ici le message !!
https://github.com/openshift/machine-config-operator/blob/671a5546fd3445b50ea5f4259378683cd329025f/pkg/server/bootstrap_server.go
>
func (bsc *bootstrapServer) GetConfig(cr poolRequest) (*runtime.RawExtension, error) {
	if cr.machineConfigPool != "master" {
		return nil, fmt.Errorf("refusing to serve bootstrap configuration to pool %q", cr.machineConfigPool)
	}
///
Putain voici le commit :
https://github.com/openshift/machine-config-operator/commit/c58b8f9687dd6ea8b245fa8901bc0ab3cc99d439




curl -k -v https://api-int.ocp4-cluster-001.sandbox.okd:22623/config/worker



ssh damien@10.0.5.62 connection refused ...

master OK je dois determiner comment celui ci est up
curl -k -v https://api-int.ocp4-cluster-001.sandbox.okd:22623/config/master

ssh damien@10.0.5.59 connection refused ...

La connection est accessible une fois que le fichier à merger dans la conf est recuperé


dans mes conf j'ai une notion de merge ...
"merge": [
        {
          "source": "https://api-int.ocp4-cluster-001.sandbox.okd:22623/config/worker"
        }
      ]
peut être qu'il est en attente et une fois recu il applique la conf ...



# TODO prefixer avec le numero de cluster pour worker et control plane ! et bootstrap !!!

putain une fois que bootstrap a redemarre mes

https://api.ocp4-cluster-001.sandbox.okd:6443/version?timeout=32s:
10.0.5.57 envoie vers le loadbalander
6443
                    backend ocp4_k8s_api_be
                        balance roundrobin
                        mode tcp
                        server      bootstrap 10.0.5.58:6443 check
                        server      control-plane-0 10.0.5.59:6443 check

docker run -ti giantswarm/tiny-tools sh



https://jamielinux.com/docs/libvirt-networking-handbook/custom-nat-based-network.html


rpm-ostree install telnet


nmcli dev show


dans le cluster okd !!! partie dnsmasq
Rajouter comme configuration


touch /etc/dnsmasq.d/virbr-okd-dns.conf && \
echo "except-interface=virbr-okd-dns" >> /etc/dnsmasq.d/virbr-okd-dns.conf && \
systemctl restart dnsmasq

service dnsmasq restart

journalctl -u dnsmasq

iptables -A INPUT -i virbr-okd-dns -p udp -m udp -m multiport --dports 53,67 -j ACCEPT && \
  iptables -A INPUT -i virbr-okd-dns -p tcp -m tcp -m multiport --dports 53,67 -j ACCEPT


iptables -t nat -I POSTROUTING -o wlp82s0 -j MASQUERADE



ip neighbor

dnsmasq --conf-file=/var/lib/dnsmasq/virbr-okd-dns/dnsmasq.conf --pid-file=/var/run/virbr-okd-dns.pid

> dnsmasq   10179 nobody    7u  IPv4 117760      0t0  TCP 10.0.6.1:53 (LISTEN)
Youpi !!!

  lsof -i -P -n |grep dnsmasq


# libvert change is setup


                              strict-order
                              domain=ocp4-cluster-001.sandbox.okd
                              expand-hosts
                              pid-file=/var/run/libvirt/network/okd-dns0.pid
                              except-interface=lo
                              bind-dynamic
                              interface=virbr-okd-dns
                              dhcp-range=10.0.6.10,10.0.6.254
                              dhcp-no-override
                              dhcp-authoritative
                              dhcp-lease-max=245
                              dhcp-hostsfile=/var/lib/libvirt/dnsmasq/okd-dns0.hostsfile
                              addn-hosts=/var/lib/libvirt/dnsmasq/okd-dns0.addnhosts



fix an issue when we want the load balancer vm to communicate with the dns vm (Destination Port Unreachable)

iptables -I FORWARD 1 -j ACCEPT

putain il faut que je rajoute ces regles et si je redemmare je suis dans le mouise... car elle vont disparaitre ou pas se
retrouver dans la meme priorité ...
passer par un hook au demarrage de la vm pour reecrire la table iptable !!!

iptables -I FORWARD 1 -d 10.0.6.0/24 -j ACCEPT && \
iptables -I FORWARD 1 -s 10.0.6.0/24 -j ACCEPT && \
iptables -I FORWARD 1 -d 10.0.5.0/24 -j ACCEPT && \
iptables -I FORWARD 1 -s 10.0.5.0/24 -j ACCEPT

iptables -L -v --line-numbers
systemctl restart iptables

ok il faut que j'utilise un network open !

systemctl restart iptables
systemctl status iptables



iptables -D FORWARD 4
iptables -F

il faut envoyer un SIGHUP sur le process root de libvirt ... kill -1 45737
et du coup toutes mes tables de routage changes et bingo cela ne marche plus !!!



/var/lib/libvirt/dnsmasq


openshift-install wait-for bootstrap-complete --log-level debug

openshift-install wait-for install-complete --log-level debug

faire un script pour preparer le Host : soit ipv4 forward ...


https://console-openshift-console.apps.ocp4-cluster-001.sandbox.okd



    # ok go pour cette configuration
    # https://github.com/openshift/okd/issues/28
    # https://builds.coreos.fedoraproject.org/browser
    # testing
    # https://builds.coreos.fedoraproject.org/prod/streams/testing/builds/31.20191217.2.0/x86_64/fedora-coreos-31.20191217.2.0-qemu.x86_64.qcow2.xz
    # okd_version: "4.3.0-0.okd-2019-11-15-182656"
    # fedora_coreos_cloud_image_name: "fedora-coreos-31.20191217.2.0-qemu.x86_64.qcow2"
    # fedora_coreos_cloud_image_name_archive: "fedora-coreos-31.20191217.2.0-qemu.x86_64.qcow2.xz"



#    okd_version: "4.4.0-0.okd-2020-01-28-022517"
    #fedora_coreos_cloud_image_name: "fedora-coreos-31.20191217.2.0-qemu.x86_64.qcow2" marche pas
    #fedora_coreos_cloud_image_name: "fedora-coreos-31.20200310.3.0-qemu.x86_64.qcow2" marche pas
    #fedora_coreos_cloud_image_name: "fedora-coreos-31.20200127.3.0-qemu.x86_64.qcow2" marche pas
#    fedora_coreos_cloud_image_name: "fedora-coreos-31.20200323.2.1-qemu.x86_64.qcow2" # marche pas
    # Trouver pourquoi !!!!! bootstrap ne demarre pas !!!! OK elle demarre si je n'ai pas le fichier d'ignition... voir pourquoi
    # Tester avec un fichier d'ignition simple (worker) OK il passe
    # Trouver ou cela pose probleme dans le fichier de bootstrap !!! Et la galère continue !!! Comment debugger ignition
    # Error at $.storage.file.48 line1 col 112716 duplicate entry defined
    # Error at $.storage.file.49 line1 col 114217 duplicate entry defined
    # ok je dois corriger via mon script python ceci : https://github.com/openshift/installer/pull/3078
    # doublon: /opt/openshift/openshift/99_openshift-machineconfig_99-master-ssh.yaml et /opt/openshift/openshift/99_openshift-machineconfig_99-worker-ssh.yaml
    # remove: /usr/local/bin/report-progress.sh ATTENTION: generer le fichier avec la derniere version puis VERIFIER !


  # fix storage issue when generating bootstrap.ign
  # Error at $.storage.file.48 line1 col 112716 duplicate entry defined
  # Error at $.storage.file.49 line1 col 114217 duplicate entry defined
  # /opt/openshift/openshift/99_openshift-machineconfig_99-master-ssh.yaml
  # /opt/openshift/openshift/99_openshift-machineconfig_99-worker-ssh.yaml
  # storage = data["storage"]
  # print getattr(storage, "file")
  # unique = { each["path"] : each for each in data["storage"]["file"] }.values()
  # print unique





Configurer un proxy registry




> creer une machine container-registry
 - meme niveau que dns
> tester avec une image fcos (un autre master)
> verifier que le container registry contient les images :)
> faire du docker pull dans l'image vis à vis de


https://computingforgeeks.com/create-docker-container-registry-with-podman-letsencrypt/
/etc/containers/registries
unqualified-search-registries = ['registry.access.redhat.com', 'docker.io']
registries = ['myregistry.local','registry.computingforgeeks.com:5000']

-rw-r--r--. 1 root root   76  6 avril 21:14 registries.conf

